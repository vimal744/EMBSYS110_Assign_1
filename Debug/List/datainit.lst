###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       14/Apr/2016  18:00:33
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\mehta\Desktop\STM32F401\E110\Assignment_1\uDebugger_vimalm\BSP\datainit.c
#    Command line =  
#        C:\Users\mehta\Desktop\STM32F401\E110\Assignment_1\uDebugger_vimalm\BSP\datainit.c
#        -D USE_STDPERIPH_DRIVER -D STM32F401xx -lCN
#        C:\Users\mehta\Desktop\STM32F401\E110\Assignment_1\uDebugger_vimalm\Debug\List
#        -o
#        C:\Users\mehta\Desktop\STM32F401\E110\Assignment_1\uDebugger_vimalm\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I .\ -I
#        C:\Users\mehta\Desktop\STM32F401\E110\Assignment_1\uDebugger_vimalm\Util\
#        -I
#        C:\Users\mehta\Desktop\STM32F401\E110\Assignment_1\uDebugger_vimalm\BSP\
#        -I
#        C:\Users\mehta\Desktop\STM32F401\E110\Assignment_1\uDebugger_vimalm\BSP\CMSIS\
#        -I
#        C:\Users\mehta\Desktop\STM32F401\E110\Assignment_1\uDebugger_vimalm\BSP\ST\StdPeripheralDrivers\
#        -I
#        C:\Users\mehta\Desktop\STM32F401\E110\Assignment_1\uDebugger_vimalm\Task\
#        -I
#        C:\Users\mehta\Desktop\STM32F401\E110\Assignment_1\uDebugger_vimalm\Types\
#        -On
#    List file    =  
#        C:\Users\mehta\Desktop\STM32F401\E110\Assignment_1\uDebugger_vimalm\Debug\List\datainit.lst
#    Object file  =  
#        C:\Users\mehta\Desktop\STM32F401\E110\Assignment_1\uDebugger_vimalm\Debug\Obj\datainit.o
#
###############################################################################

C:\Users\mehta\Desktop\STM32F401\E110\Assignment_1\uDebugger_vimalm\BSP\datainit.c
      1          /**
      2           * datainit.c
      3           * Overlay the initialization data onto the RAM region that contains them
      4           * Zero initialize the bss section
      5           */
      6          #include <stdint.h>
      7          
      8          /*
      9           * a pragma is a compiler specific extension
     10           *  This pragma section extension is used to tell the linker the sections used in this file
     11           */
     12          #pragma section = ".data_init"          /*  !< These are the values to assigned to the globals (in flash) */
     13          #pragma section = ".data"               /* !< This is where the globals reside in RAM */
     14          #pragma section = ".bss"                /* !< This is the zero-init area */
     15          
     16          
     17          /**
     18            ** \brief Called before the data section is initialized, do
     19            ** not use any globals
     20            ** IAR linkers uses the "__section_begin" and "__section_end"  to populate the
     21            ** variable with the actual value at link time. Keil uses a similar method. GCC is completely different.
     22            ** This function is also set to the entry point in the ELF header. (see project->options->linker->library)
     23            **/

   \                                 In section .text, align 4, keep-with-next
     24          void InitializeDataSection(void)
     25          {
   \                     InitializeDataSection: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
     26              /**
     27               ** section_begin is an IAR helper to get information about sections. The linker
     28               **  populates the correct data
     29               **/
     30              uint8_t*   pInitDataSource = __section_begin(".data_init");
   \   00000002   0x480D             LDR.N    R0,??InitializeDataSection_0
     31              uint8_t*   pInitDataTarget = __section_begin(".data");
   \   00000004   0x490D             LDR.N    R1,??InitializeDataSection_0+0x4
     32              uint8_t*   pInitDataEnd    = __section_end(".data_init");
   \   00000006   0x4A0E             LDR.N    R2,??InitializeDataSection_0+0x8
     33                
     34              /* Figure out how much data to copy */
     35              uint32_t    size = pInitDataEnd - pInitDataSource;
   \   00000008   0x1A13             SUBS     R3,R2,R0
     36          
     37              /* Do the copy of the initialization values onto the RAM area */
     38              while (size--) {
   \                     ??InitializeDataSection_1: (+1)
   \   0000000A   0x001C             MOVS     R4,R3
   \   0000000C   0x1E63             SUBS     R3,R4,#+1
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD004             BEQ.N    ??InitializeDataSection_2
     39                *pInitDataTarget++ = *pInitDataSource++;
   \   00000012   0x7804             LDRB     R4,[R0, #+0]
   \   00000014   0x700C             STRB     R4,[R1, #+0]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x1C49             ADDS     R1,R1,#+1
   \   0000001A   0xE7F6             B.N      ??InitializeDataSection_1
     40              }   
     41              
     42              /* Zero initialized section is called bss, give it the same treatment */
     43              uint8_t* pZeroInit = __section_begin(".bss");
   \                     ??InitializeDataSection_2: (+1)
   \   0000001C   0x4C09             LDR.N    R4,??InitializeDataSection_0+0xC
     44              uint8_t* pZeroInitEnd = __section_end(".bss");
   \   0000001E   0x4D0A             LDR.N    R5,??InitializeDataSection_0+0x10
     45              size = pZeroInitEnd - pZeroInit;
   \   00000020   0x1B2E             SUBS     R6,R5,R4
   \   00000022   0x0033             MOVS     R3,R6
     46              while (size--) {
   \                     ??InitializeDataSection_3: (+1)
   \   00000024   0x001E             MOVS     R6,R3
   \   00000026   0x1E73             SUBS     R3,R6,#+1
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD003             BEQ.N    ??InitializeDataSection_4
     47                *pZeroInit++ = 0;
   \   0000002C   0x2600             MOVS     R6,#+0
   \   0000002E   0x7026             STRB     R6,[R4, #+0]
   \   00000030   0x1C64             ADDS     R4,R4,#+1
   \   00000032   0xE7F7             B.N      ??InitializeDataSection_3
     48              }       
     49          }
   \                     ??InitializeDataSection_4: (+1)
   \   00000034   0xBC70             POP      {R4-R6}
   \   00000036   0x4770             BX       LR               ;; return
   \                     ??InitializeDataSection_0:
   \   00000038   0x........         DC32     SFB(`.data_init`)
   \   0000003C   0x........         DC32     SFB(`.data`)
   \   00000040   0x........         DC32     SFE(`.data_init`)
   \   00000044   0x........         DC32     SFB(`.bss`)
   \   00000048   0x........         DC32     SFE(`.bss`)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   InitializeDataSection


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      76  InitializeDataSection

 
 76 bytes in section .text
 
 76 bytes of CODE memory

Errors: none
Warnings: none
